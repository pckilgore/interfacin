package store_test

import (
	"context"
	"math/rand"
	"pckilgore/app/pointers"
	. "pckilgore/app/store"
	"testing"

	"github.com/stretchr/testify/require"
)

var next = (func() func() int {
	count := 0
	return func() int {
		count++
		return count
	}
})()

func CreateStoreTest[D Storable, P Parameterized](
	t *testing.T,
	s Store[D, P],
	// Build a model. for each call, nonce is guaranteed to be unique.
	modelBuilder func(nonce int) D,
	// Validate that no deserialization errors occured.
	modelValidator func(t *testing.T, model D),
	// Generate search parameters.
	paginationBuild func(limit int, after *Cursor, before *Cursor) P,
	// Generate filter.
	filterBuild func(generatedData []D) P,
	// Validate results against params generated by filterBuild.
	filterValidator func(t *testing.T, params P, resultSet []D),
) {
	ctx := context.Background()
	var ids []string

	t.Run("Create", func(t *testing.T) {
		model := modelBuilder(next())
		c, err := s.Create(ctx, model)
		require.Nil(t, err, "store.Create should not error")
		modelValidator(t, *c)
		ids = append(ids, (*c).GetID())

		c, err = s.Create(ctx, model)
		require.Nil(t, c, "should not create duplicate models")
		require.NotNil(t, err, "should error when attempting to create duplicate")
	})

	t.Run("Retrieve", func(t *testing.T) {
		for i := 0; i < 150; i++ {
			m, err := s.Create(ctx, modelBuilder(next()))
			require.Nil(t, err, "failed to create multiple models for testing")
			ids = append(ids, (*m).GetID())
		}

		// We check the first ID always, since we're going to check that's it's
		// removed later.
		first, found, err := s.Retrieve(ctx, ids[0])
		require.Nil(t, err, "store.Retrieve should not error")
		require.Truef(t, found, "store.Retrieve should be able to find id=%s in the store", ids[0])
		modelValidator(t, *first)

		randomId := ids[rand.Intn(len(ids))]
		r, found, err := s.Retrieve(ctx, randomId)
		require.Nil(t, err, "store.Retrieve should not error")
		require.Truef(t, found, "store.Retrieve should be able to find id=%s in the store", randomId)
		modelValidator(t, *r)
	})

	t.Run("paginationBuild contract", func(t *testing.T) {
		t.Parallel()
		for limit := 1; limit < 100; limit++ {
			var before *Cursor
			var after *Cursor
			if limit%2 == 0 {
				before = pointers.Make(NewCursor(ids[rand.Intn(len(ids))]))
			} else if limit%5 == 0 {
				after = pointers.Make(NewCursor(ids[rand.Intn(len(ids))]))
			}

			params := paginationBuild(limit, after, before)
			require.Equal(t, limit, params.Limit(), "paginationBuild did not set limit")
			require.Equal(t, before, params.Before(), "paginationBuild did not set Before")
			require.Equal(t, after, params.After(), "paginationBuild did not set After")
		}
	})

	t.Run("List", func(t *testing.T) {
		t.Run("pagination", func(t *testing.T) {
			limit := 77
			params := paginationBuild(limit, nil, nil)
			list, err := s.List(ctx, params)
			require.Nil(t, err, "store.Lister should not error")
			require.Equal(t, len(ids), list.Count)
			require.Equal(t, limit, len(list.Items))

			params = paginationBuild(100, list.After, nil)
			list, err = s.List(ctx, params)
			require.Nil(t, err, "store.Lister should not error")
			require.Equal(t, len(ids), list.Count, "still expect same total count")
			require.Equal(t, len(ids)-limit, len(list.Items), "the next page should only contain this many items")

			// Get first page of ten.
			params = paginationBuild(10, nil, nil)
			firstPage, err := s.List(ctx, params)
			require.Nil(t, err, "store.Lister should not error")

			// Get next page of ten.
			params = paginationBuild(10, firstPage.After, nil)
			secondPage, err := s.List(ctx, params)
			require.Nil(t, err, "store.Lister should not error")

			// Get first page (again).
			params = paginationBuild(10, nil, secondPage.Before)
			firstPageRedux, err := s.List(ctx, params)
			require.Nil(t, err, "store.Lister should not error")
			require.Equal(t, firstPage, firstPageRedux, "first page should be the same")
		})

		t.Run("invalid pagination", func(t *testing.T) {
			params := paginationBuild(10, &Cursor{}, &Cursor{})
			_, err := s.List(ctx, params)
			require.NotNil(t, err, "store.Lister should err with both before and after cursors")
		})

		t.Run("filtering", func(t *testing.T) {
			params := paginationBuild(50, nil, nil)
			list, err := s.List(ctx, params)
			require.Nil(t, err)
			params = filterBuild(list.Items)
			list, err = s.List(ctx, params)
			require.Nil(t, err)
			filterValidator(t, params, list.Items)
		})
	})

	t.Run("Delete", func(t *testing.T) {
		deleted, err := s.Delete(ctx, ids[0])
		require.Nil(t, err)
		require.True(t, deleted)
		_, found, err := s.Retrieve(ctx, ids[0])
		require.Nil(t, err)
		require.False(t, found)

		deleted, err = s.Delete(ctx, ids[0])
		require.Nil(t, err)
		require.False(t, deleted)

		// Cleanup entire Store
		for _, id := range ids[1:] {
			deleted, err := s.Delete(ctx, id)
			require.Nil(t, err)
			require.True(t, deleted)
		}

		list, err := s.List(ctx, paginationBuild(100, nil, nil))
		require.Nil(t, err)
		require.Len(t, list.Items, 0, "nothing should remain in DB")
	})
}

func CreateTreeStoreTest[D TreeStorable, P Parameterized](
	t *testing.T,
	s TreeStore[D, P],
	// Build a model. for each call, nonce is guaranteed to be unique. If a non,
	// nil parentID is provided, the builder MUST use it in such a way that D
	// satifies the [Treeable] interface with it.
	modelBuilder func(nonce int, parentID *string) D,
	// Validate that no deserialization errors occured.
	modelValidator func(t *testing.T, model D),
	// Generate search parameters.
	paginationBuild func(limit int, after *Cursor, before *Cursor) P,
	// Generate filter.
	filterBuild func(generatedData []D) P,
	// Validate results against params generated by filterBuild.
	filterValidator func(t *testing.T, params P, resultSet []D),
) {
	// If it can't do this, we can't test tree stuff.
	CreateStoreTest[D, P](
		t,
		s,
		func(nonce int) D {
			return modelBuilder(nonce, nil)
		},
		modelValidator,
		paginationBuild,
		filterBuild,
		filterValidator,
	)

	ctx := context.Background()

	root, err := s.Create(ctx, modelBuilder(next(), nil))
	require.Nil(t, err)
	rootID := (*root).GetID()

	childA, err := s.Create(ctx, modelBuilder(next(), pointers.Make(rootID)))
	require.Nil(t, err)
	childAID := (*childA).GetID()

	childB, err := s.Create(ctx, modelBuilder(next(), pointers.Make(rootID)))
	require.Nil(t, err)
	childBID := (*childB).GetID()

	childC, err := s.Create(ctx, modelBuilder(next(), pointers.Make(childBID)))
	require.Nil(t, err)
	childCID := (*childC).GetID()

	t.Run("ListAncestors", func(t *testing.T) {
		t.Parallel()
		list, err := s.ListAncestors(ctx, childCID)
		require.Nil(t, err)
		require.Len(t, list.Items, 3)

		list, err = s.ListAncestors(ctx, childAID)
		require.Nil(t, err)
		require.Len(t, list.Items, 2)
	})

	t.Run("ListDescendants", func(t *testing.T) {
		t.Parallel()
		list, err := s.ListDescendants(ctx, rootID)
		require.Nil(t, err)
		require.Len(t, list.Items, 4)
		require.Subset(t, list.Items, []D{*root, *childA, *childB, *childC}, "should contain the whole tree")

		list, err = s.ListDescendants(ctx, childAID)
		require.Nil(t, err)
		require.Len(t, list.Items, 1)
		require.Subset(t, list.Items, []D{*childA})
	})
}
